# 上位机学习笔记

命名空间，类库(dll)，库管理和引用

生成（不会删除没有修改的dll），重新生成（先清理了在生成，会删除本地dll）。

## C#编程规范和语法强化

一、编程规范相关

1、关于平台的选择和项目类型。

【1】控制台程序：这个主要是给我们学习使用的。

【2】桌面程序、web程序、库

项目平台：

【1】.NET Framework （从.NET出现第一天的时候，用的就是这个，这个是托管程序）

    版本：2.0   4.0    4.6（最多）   4.7-4.8

【2】.NET Core（全栈班的学员，这个是非常重要的）可以运行到Linux平台的。

注意：我们目前阶段，尤其是基础部分，都是用.NET Framework，不要选错。

2、解决方案和项目

【1】学会创建项目的时候，同时创建解决方案。（解决方案和默认项目名称是一样的）

【2】独立创建空白解决方案，然后添加不同的项目。（解决方案的名称是独立命名的）

【3】解决方案的作用

在当前解决方案中，添加一个类库。这样的话，解决方案中，就有一控制台和一个类库项目。

项目的区别：我们创建的一个控制台、windows程序、web程序、类库，等在解决方案中，都是不同的项目。

我们平时开发说的开发项目，是一个大的应用程序。

一个解决方案中，可以添加若干独立的项目。

解决方案中，项目之间的引用，必须有一定的关系。不能交叉引用。

控制台程序A-->类库1-->类库2。。。。

类库C   引用关系一定的单项的。不能互相引用。

作用1：统一的管理各个项目，和编译项目。

作用2：统一清理解决方案各个项目。

什么时候用清理？当我们调试次数过多的时候，导致调试不正常了，可以清理一下。会自动删除生成的dll等文件。

当然，万一自动清理不起作用，请手动删除。

【4】关于类库

类库将来生成的都是独立的dll文件（动态链接库），不能独立运行，必须被其他的项目引用或其他方式使用。

主要用来封装独立功能的模块。比如这个项目用的模块，也可以被其他的项目使用。

关于引用：我们除了可以引用本地项目的，还可以引用云服务器上面的。（nuget，这个用的也非常多）

引用使用：添加引用后，在使用类的时候，必须要引入命名空间，如果我们引入了多个模块，万一类名有重复，
这时候，我们要使用完全限定名：命名空间 +类名。

3、关于命名空间

【1】作用：主要是为了更好的管理类，和对类分类。尤其是不同的命名空间可以用同名类。

【2】修改：通过项目属性修改，后面添加的时候，默认都是新的命名空间。

4、关于目标框架的修改

我们建议开发中，当前解决方案中的所有的项目框架版本都一致，这样是最好的。

特殊情况：

当你引用第三方的dll文件的时候，这个dll文件框架版本，必须等于或低于你当前项目的版本。

5、关于注释

【1】单行注释
【2】文档注释

6、元数据和反编译使用

【1】元数据：是VS提供给我们开发者，可以快速查看类或方法定义的途径。但是没有源码。
【2】ILSpy扩展：可以实现源码的查看。这个需要我们单独去安装插件。

7、代码规范

【1】命名空间和类：类必须放到命名空间里面。方法必须放到类里面。类一般不能嵌套类。

【2】命名：类和方法、属性命名的时候，都是首字母大写。用的是Pascal命名法。

 局部变量和字段，都是首字母小写，用的是Camel命名法。

二、部分语法强化

1、字符串格式化。目的就是为了更好的拼接字符串。

【1】以前的写法，使用0、1、2...占位符。

 可以在Console.WriteLine（）和string.Format中使用。

2、字符串的分割split

前提：字符串必须有严格的分隔符。

常见的分隔符：,   -  _  |        \r\t

3、字符串的合并join

4.字符串的替换

## C#面向对象（OOP）中的属性

授课老师：常老师

---

目的：希望大家正确理解什么是面向对象编程？如何学好面向对象编程？把面向对象编程开好的头！

面向对象编程是一种思想和体系。这种思想和体系，不是专门归属于某一种语言。（C#、java）

学好一门面向对象的编程语言，就应该把面向对象的思想和体系掌握！

面向对象的思想和体系包括：
【1】面向对象编程各种原则（六大原则）原则就是告诉你缩写的程序应该满足什么样条件和情况。
【2】各种方法（基本的方法、深入的各种方法，这个也是我们学习的最多的，主要指知识点和技能点：继承、接口、多态...等具体化内容）但是，我们使用各种方法的时候，肯定会用到各种原则。
【3】具体问题具体分析。针对特定的问题，就应该有各种解决方案。（设计模式，不是学的越多越好...）
【4】自己的经验。（结合项目）

程序的基本单元？类

设计程序（软件）本质就是设计什么？各种各样的类。

软件的组成：各种模块（类库\可启动项目）组成。（UI-->数据处理（基层员工）-->业务处理（中层）<-->数据对象）

数据对象（实体数据类）：在程序处理中，所有的数据都会以对象为载体，封装和解析数据。

目标：学会基础对象的设计和使用。

一、类的组成

1、属性（用来存储数据）（属性是数据存储的入口）

2、方法（就是解决数据和业务是如何处理的）

3、接口...

二、类的属性

一个类应该设计什么样的属性？这个是根据我们的用户需求分析得到的。

练习：

【1】创建课程类Course

【2】针对课程的各种属性研究。

 对比：字段（成员变量）

变量：在方法内的局部变量、方法外面的成员变量。

建议：不管修饰什么类型，访问修饰符，一定要显式的写出。

面向对象编程一切皆对象：也就是我们在完成任务的时候，其实是一个个对象的创建和使用。
特点：对象用完，可以随时扔掉。
创建对象：创建一个实例，得到一个实例，new一个对象。也就是把一个类从文件状态记载到内存中，可以被我们使用。

通过刚才的示例，我们知道了，课程的信息，通过类的字段保存了。

三、关于字段

结论：存在数据不合理的情况。

建议：不要直接给调用者使用字段。应该通过属性入口，去操作数据。

目的：我们可以在属性中增加业务逻辑。

四、属性

特点1：可也增加业务。

特点2：也可以设置成只读、只写（很少）

特点3：简化的属性，如果需要字段存储，系统默认会生成。

面向对象编程，只要对外访问我们一般都用属性（OOP思想提倡的）

五、属性和字段PK

1、字段

【1】字段**一般仅供内部交互数据使用**。所以字段一般都是private。
【2】字段不能扩展业务逻辑。
【3】字段可以通过readonly变成只读，但是不能有业务。
【4】很多时候对象数据获取不认字段。

2、属性

【1】属性一般都是对外提供访问入口。所以属性都是public。
【2】可以扩展业务逻辑。
【3】根据需要设置只读属性，同时增加业务。
【4】使用属性，是OOP所提倡的。

问答：

value是哪里来的？当我们给属性赋值的时候，这个值会首先给value，然后属性内部通过value得到具体值。

属性快捷方式：prop+两个tab

自动对齐：ctrl+k+d 三个键同时按下。 （注意，如果你的代码有语法错误，可能会失效）

局部变量：只能在方法内部使用。成员变量（字段）：在类里面的方法原则上都可以使用。

ILDasm路径：C:\Program Files (x86)\Microsoft SDKs\Windows\v10.0A\bin\NETFX 4.8 Tools\x64

C# 面向对象中的程序运行：不用则静，用完则仍。  （用不到的时候，待命，用的时候创建出来，用完就销毁）

## C#面向对象编程中的构造方法、实例方法及综合练习

授课老师：常老师

---

   听直播，你听什么？ 听思路，看看问题解决方法。（哪怕这一节课，你听懂一个问题思路）

   听直播课，和电影院看电影是一样的，需要的是一种感觉。（思路，感受现场的氛围）

---

一、回顾：属性

属性表示对象的静态特征。属性就是用来存储数据的。

属性是存储数据的入口。数据具体可以存储在字段中，也可以存储在文件中、数据库中。。。。

属性的本质是方法。

方法表示对象的动态特征。方法就是用来完成任务。（数据如何处理）

二、构造方法

核心：构造方法（析构方法）、实例方法/静态方法

1、构造方法（Constructor）：构造对象其实就是创建对象。也就是我们在创建对象过程中，需要调用的方法，叫做构造方法。

研究构造方法：主要是研究对象是如何初始化的。

构造方法默认：当我们编写一个类的时候，如果你没有显式地写出任何构造方法，这时候编译器编译的时候，会个这个类默认添加一个无参数的构造方法。当然你如果添加了任意形式的构造方法，默认的都不会在产生。

构造方法规范：

public 类名称（[参数1]，[参数2]...）
{

}
注意：构造方法不能有任何返回值。名称必须和类名完全一样。

调试默认构造方法的调用过程发现：

第一、首先初始化字段。
第二、初始化有默认值的属性。
第三、执行构造方法。

为什么是这样的顺序？

首先搞清楚，构造方法是用来初始化的！初始化什么？可初始化的内容有字段、属性、或其他的相关新的的读取和写入。既然在构造方法中，可能调用字段或者属性等，因此必须先对字段和属性做初始化。

2、构造方法的重载

也就是我们可以在一个类中，添加若干构造方法，这些构造方法的名称都是一样的，但是方法的参数类型或个数是不一样的。

**注意：this关键字非常总要，this后面可以使用的都是类的成员（字段、属性、方法），尤其是成员变量和局部变量同名的时候。this区分是非常必要的。**

3、构造方法之间的调用

使用:this关键字调用其他的构造方法。注意，执行的顺序是先调用内层的构造方法。

方法重载调用是根据参数的类型和个数完全对应来查找的。

三、实例方法

实例方法就是通过对象去调用的方法，是我们程序编写的核心内容。

调用形式：对象名.实例方法名（参数....）

定义规范：

访问修饰符  返回值类型  方法名称（方法参数....）
{
     //方法体....

}

访问修饰符：public、private...

返回值类型：没有返回值用void 其他的返回值类型是我们可以用的所有类型（基础数据类型、对象类型）

方法名定义：使用Pascal命名法，尽量用动宾短语，或动词

【1】没有返回值、没有参数的的方法
使用场景：通常是完成一个固定的任务，这个任务不需要参数，也不需要返回给调用者数据。
比如做数据的备份、数据的优化、定时的数据报表、相关信息的定时存储等...

【2】没有返回值，有参数的方法
使用场景：需要完成一个任务，提供一些参数，但是不需要返回给调用者。

【3】有返回值，有参数
使用场景：需要完成一个任务，提供一些参数，同时需要把结果给调用。

命名参数（也就是说调用方法的时候，给参数前面写上参数名称，这样可以不用考虑顺序）
使用场景：在参数比较多的时候，还是有用的。

四、静态方法

静态方法：就是使用static修饰的方法，不能通过对象去调用，而是直接通过类名.方法名的形式去调用。

   public static string GetStaticInfo(string equipName)
        {
            string result = $"设备ID：{EquipID} 设备名称：" +
                   $"{equipName} 压力：{Pressure} 采集时间：{CollectionTime}";
            return result;
        }

这个会出错。愿意：静态方法内部不能“直接调用实例成员（字段、属性、方法）”

静态方法的特征：

所谓静态，就是不需要new对象，直接通过类完成。这些静态的成员（字段、属性、方法）在你的程序启动的时候由CLR负责的，也就是说随着程序的启动自动初始化完成。

意味着这些静态的成员，在程序启动后，同时就存在了。

但是实例成员必须是在new之后才存在的，所以，静态的是不能直接调用实例的，原因就是实例的成员并不存在。解决方法就是调用之前，必须得到成员的实例对象。

五、总结实例方法和静态方法

实例方法或其他的成员，换句话说，我们创建的对象，在你使用完毕后，会被GC（垃圾回收机制）回收，从而释放内存，因为我们的程序，在不断的创建对象，销毁对象。

静态的成员，是不会受GC控制的，也就是说你的程序不关闭，这些成员占用的内存空间，永远都不会释放。

所以，静态的成员，必须慎重使用。使用非常频繁的，占用空间又不大的。可以适当使用。

课后作业：

 请编写一个手机类，自己分析需求，添加相关的属性，并实现装软件，拨打电话、发短信、看新闻等功能模拟。

 要求：一定要用到属性、字段、业务、实例方法、静态方法、构造方法。

分析属性：品牌、颜色、价钱、屏幕、内存....

分析方法：装软件，拨打电话、发短信、看新闻

---

### 泛型集合List `<T>`和Dictionary<k,v>

一、泛型（Generic）理解

泛型是一种程序特性，这种特性是用来限定数据类型。也就是我在声明类、方法、集合等具体所使用的相关的数据类型

并不严格限定。在使用的时候，让使用者明确限定，并且不可更改。

买电脑：操作系统的账户，出厂的时候并没有确定给谁使用，但是你们买来激活后，这个序列号就是是你用了。并且不能修改。

对比：string[]      int[]      Teacher[]  数组在定义的时候，是不是类型确定？yes！

二、泛型集合List `<T>`

1、为什么要用集合？

对比数组发现，数组定义的时候，必须明确元素个数。

但是实际应用中，有可能需要存储的元素个数大于数组定义的个数，这种情况就得修改，太麻烦。

集合声明的时候不需要限定元素个数，根据实际的需要自动增长。

2、为什要用泛型集合？

就是集合在给我们定义的时候，并没有限定具体的元素类型，我们在使用的时候，需要限定，非常方便。

对比：ArrayList myList=new ArrayList（）；非泛型集合是object类型。

3、泛型集合List `<T>`

请参考代码中所用的集合的属性和各种方法。

三、泛型集合Dictionary<k,v>  （Hastable哈希表）

1、Dictionary<k,v>字典集合

字典：偏旁部首或拼音--->汉字页数

好处：对于我们开发者来说非常容易的根据一个key（名字），找到对应的一个值（对象或其他类型的数据）

2、具体使用（参加代码即可）

四、总结集合

本质：就是学习使用对象的容器，因为后面我们所有处理的对象，都是放到容器中。

## Windows项目结构分析、UI设计和综合事件应用

授课老师：常老师

---

windows项目是我们.NET学习一开始必备的内容。

1、窗体类（主代码文件+窗体设计器后台代码文件）

    主窗体对象的创建：在Program类里面：  Application.Run(new FrmMain());

    这句代码就决定了，当前窗体是项目的主窗体。也就是作为项目的主线程运行。如果你关闭主窗体，整个项目会退出。

   特点：继承自Form类。

   部分类partial关键字。可以将两个同名的类关联起来，其实“这两个类”本质上是一个类，也就是为了方便维护和代码编写，把窗体设计器自动生成的代码，放到另一个部分类中。最后VS编译器编译的时候，还是编译到一起的。

   这个可以通过ILDASM查询IL得到证实。

2、控件对象与窗体容器集合（Control）

【1】控件和组件的区别：控件是在窗体上可见的。组件是在窗体下面不可见的，也就是不占用窗体的空间。也就是没有可视化的界面。

【2】按钮控件的使用与代码分析。控件从拖放到显示，经过的步骤：

第一、创建该对象的成员变量。

第二、初始化这个成员变量的相关属性。（我们可以通过可视化属性窗口完成）

第三、窗体本身是一个容器，所有的控件，都会加到Controls集合中。

当我在窗体上添加一个容器控件的时候（比如GroupBox或者Panel）容器控件和其他的控件一样，也会被添加到Controls集合中。当我在容器中添加相关的控件的时候，这时候，容器中的控件，会添加到当前容器的Controls集合中，而不是窗体的Controls中，请大家务必记住。

3、Windows的事件驱动机制

【1】生活中的事件驱动机制。（疫情）下面是事件完整的模型：

 提前指定疫情预案-->定义事件

针对疫情具体解决 -->处理事件

    预案和疫情关联-->关联事件

疫情出现激发预案 -->激发事件

【2】程序中的事件。以按钮单击事件分析模型。

第一、事件定义（框架自带的）框架已经提前定义好了相关事件。

第二、事件处理（我们选择的）

  private void btnTestEvent_Click(object sender, EventArgs e)
        {

    }

第三、事件关联：  this.btnTestEvent.Click += new System.EventHandler(this.btnTestEvent_Click);

第四、事件激发：（用户单击按钮的行为）

4、事件的统一关联

  foreach ( Control item in this.Controls)
            {
                if ( item is Button && item.Tag.ToString() == "btn")
                {

    }

    }

Tag没有数据的时候，会出现null对象的问题：System.NullReferenceException:“未将对象引用设置到对象的实例。”

这个问题会经常出现。大家要学会判断。

当我们按照上面的方法，增加一个新的按钮，只需要设置一下Tag=btn，事件自动关联。

这个其实就是模拟了软件开发中，当用户需求变化的时候，我们可以扩展内容，但是没有修改内容。

这个正是面向对象编程中的“开闭原则”。开发扩展，封闭修改。

## OOP的基础原则和OOP案例实战

学习目的：学会类的基本设计，搞清楚类之间的关系，正确运用所学知识点。

---

一、【回顾】控件使用和Event事件机制

1、事件机制四个模型

定义事件（框架定义好的） 处理事件（这个是我们开发的重点）关联事件（委托实例和事件关联） 激发事件（用户行为）

2、综合案例（课程讲解了一个）

“阅读理解”：给你一个源程序，看看老师是怎么写的？为什么这么写？你自己能不能看懂后写出来？或者再改进一下。

---

二、OOP的基础原则

1、面向对象编程学什么？面向对象就是学习OOP的各种原则、方法（天天在用的）、技巧（基础知识灵活的组合或者解决问题的技巧）、模式（20+种设计模式，等你学的差不多了，再去看）、经验。

原则：因为这个是指导思想。公认的有六大原则。

第一、对象职责明确原则。（对象单一职责）：我们设计一个对象（类）它所包括的各种行为，必须的对象本身的。

人：属性、方法，都是人的特征。常见错误：设计万能类。

第二、开放封闭原则。我们的程序设计应该尽可能的考虑用户的需求变化，当需求真的变化时做到轻松扩展，很少修改。

开发了扩展（增加对象、增加配置）、封闭修改（原有的业务逻辑代码，最好不要去动）

第三、里氏替换原则。（我们学习继承的时候，要用的，接口也是类似的，你必须要掌握的！！！！！！！！）

   public partial class FrmMain : Form

在上面的继承中，Form是父类，FrmMain是子类。

FrmMain  frm=new FrmMain（）；

Form frm=new FrmMain（）；

   Form frm = new FrmMain();
            frm = new Form1();

//其实这个Run方法里面类型就是Form类型（父类类型，实际我们传递的时候是子类对象）
 Application.Run(new FrmMain());

目的：通常是和多态关联的。

第四、迪米特法则（最小耦合原则，最小知道原则、最小知识原则）==>高级内聚、低耦合

也是我们后面学习项目的分层架构，分模块，重要的理论依据。

第五、接口隔离原则。

第六、依赖倒置原则。（面向抽象编程、面向接口编程、面向切面编程....）归根结底还是为了项目的扩展。

父类  变量=子类对象

接口  变量=接口实现类对象

依赖抽象（写程序、模块衔接）而不是依赖细节（具体）。

---

三、OOP案例（录播里面的彩票选号器）

学习目的：学会类的基本设计，体会面向对象单一职责的应用。熟练应用对象的方法。明确对象之间的关系。

难度指数：* *  * * *  （最高难度）

最终目标：希望大家通过这个案例真正明白，我们写程序就是在构建各种类，然后使用各种对象完成我们需要的任务。

-->找到类（一个项目应该设计什么样的类？数据库应用类、上位机通信+数据库应用类、工具软件类）

经验：数据库应用项目==>数据访问类、业务逻辑类、实体类、通用工具类、服务类、UI类

    上位机应用项目==>数据访问类、业务逻辑类、实体类、通用工具类、服务类、UI类、通信库（各种通信类）

（最难的）工具软件类==>实体类（纯粹封装数据的类）、独立业务类、逻辑控制类、UI类（常老师给大家的套路）

设计实战：分析彩票选好器

实体类：DoubleChromosphere

独立的业务类：（针对某一个功能和对象实现的具体业务，可能会有多个）我们目前主要实现动态的选号。

对象之间的关系：一对一、一对多。

逻辑控制类和UI类：如果项目小，可以放到一起，如果项目大，通常是分开的。

## .NET中的继承和多态机制

---

目标：学会继承，懂得多态==》阅读代码会非常有帮助（.NET框架的代码、项目框架的代码、设计模式学习）

一、继承基础

1、概念：从生活中继承非常容易理解。物质的继承，通常是由一个人，转移到另一个人或其他人。也就是前人把某种东西给到后人。软件中的继承，也是这个道理，只不过这种继承的载体是类与类之间。（或者说对象之间）

A类-->B类（A类可以被继承的，B类都可以使用）-->C类（道理是一样的）--->。。。。

继承的单向传递性；继承具有单根性，也就是只能有一个父类（不能被循环继承、反向继承、多项继承）

2、使用方向：

第一、复用代码。

第二、多态扩展。

二、继承与代码复用

1、引出：同类型的对象分析时，出现相同的静态特征和动态特征。如果单独设计，则会出现重复代码。

弊端：维护非常麻烦。

2、复用：把不同对象之间共同的属性和方法抽取出来，放到一个特定类中，然后其他的类通过继承的方式得到或者说

复用这部分共同的代码。

base关键字：表示调用父类的成员（属性或者方法）

3、独立使用（和普通对象完全一样，仅仅是为了节省代码）

应用场合：窗体就是这种情况！控件也是这种情况！自定义控件也是如此！

三、继承扩展使用

1、抽象方法。

引出：如果我们只是使用单独的继承，把公共方法抽取出去后，当子类调用的时候，父类所提供的行为业务几乎是一样的。但是实际的情况下，子类通常会有自己特定的行为业务。但是我们又想让所有的子类，都具有这种行为。

概念：抽象方法就是在父类中规定方法的签名（定义），但是方法的具体业务内容没有。这个业务的实现，是有子类独立完成的。

要求：使用抽象方法首先把类变成抽象类，然后再定义抽象方法。

2、使用：子类在继承的父类时，如果父类有抽象方法，则子类必须重写。（除非子类也是抽象类）

重写抽象方法的时候，必须使用override关键字。

这样当我们单独使用的时候，父类重写的方法，可以输出不同的内容，子类特有的方法还能继续使用。

3、里氏替换原则：

Teacher teacherChang = new Teacher();
可以被下面的替换：
 Person teacherChang = new Teacher();

记住：父类变量接收子类对象。接口变量接收接口实现类对象。

注意：当我们是用父类类型的时候，子类特有的行为和属性会被屏蔽。

4、多态实现扩展。

六大原则：有一个面向抽象编程（能用父类的用父类、能用接口的用接口）

多态的实现1：父类作为方法的参数，实际传递的是不同的子类对象。程序运行时，所调用的抽象行为，会转到对应的子类对象所重新的方法中去。

应用场合看一下：

程序的启动入口、窗体的Controls集合。

多态的实现2：父类作为方法的返回值类型，实际返回的是具体子类

应用场景：简单工厂、抽象工厂等设计模式中

5、虚方法（也就是父类中对这个方法有一个默认的实现，子类可以重写，也可以直接使用）

子类：可以重写，也可以不重写。让子类行为更加灵活，但是没有强制性。

本周六没课：下周是3、4、6.  看我给的作业文件夹。

多态：基于.NET虚拟机特有的机制，使用继承或接口，作为方法的返回值、方法的参数，实际传递的时候或者返回的时候
是对应的子类对象或接口实现类对象。对于接口或父类来讲，他们所抽象的共同特征（抽象方法、接口）依据传递的子类对象或接口实现类对象的不同，从而表现不同的行为。

主要是在程序中慢慢体会。当你后面学习相关的设计模式或者框架的时候，基于处处都在用多态。

### 一、接口

什么是接口？ 如果从广义角度来说：接口包括应用程序的接口（主要是对外提供服务，webapi、webservice）还有，当你使用别人提供的一些库的时候，是不是有说明的文档，比如你用了C++的库。。。

从狭义上来说：接口表示一组“行为规范”。（就是没有实现的方法）

为什么要有接口：

目的：第一、也就是说用户的需求是变化的，为了适应这种变化。第二、方便团队开发，团队定义好功能，团队不同的人来实现接口。

A-->接口<---B(实现)

接口定义：简单说就是没有方法体的方法签名（但是没有修饰）。

接口特点：具有强制性。一个类实现了一个接口，就必须把接口里面的方法都要实现。

接口应用：主要是为了扩展（接口多态）和团队开发。一般团队开发这个就非常简单。

实际应用：基于接口实现多态的时候，通常接口实现类中，主要的方法就是接口的方法。

#### 接口就是用于构建架构的，

团队定义好一个框架，架构，由不同的人来实现，架构就不需要什么大变动就能跑起来。


二、接口中的反射

反射：Relection，给你一个对象，通过反射技术可以找到这个对象里面的所有内容（透视。。。这个对象内部成员）

总结：继承虽然也能实现扩展、多态，但是继承主要是复用。**接口主要是扩展。以后我们基于多态实现的时候，尽量不要用继承。**

接口可以联合反射，实现项目升级。接口里面写好需要的

学习接口多态：能够体会到面向抽象编程、开闭原则、里氏替换原则。
